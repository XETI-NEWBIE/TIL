'''
answer = input().split()

fruits = ["apple","banana","grape", "blueberry", "orange"]

count = 0

for pick in fruits:
    if answer == pick[2] or answer == pick[3]:
        print(pick)
        count+=1
    else:
        print(0)

print(count)
    
======>

1.
answer = input().split()으로 쓰면 안 되는 이유
결론부터 말하면 **"비교 대상의 격이 다르기 때문"**이에요.

input().split(): 이 결과는 항상 리스트([]) 형태입니다. 만약 'a'를 입력하면 ['a']가 되죠.

pick[2]: 이건 문자열에서 꺼낸 글자 하나입니다. 예들 들어 'apple'의 세 번째 글자인 'p'죠.

컴퓨터의 판단: "글자 뭉치(['a'])랑 글자 하나('p')가 같니?"라고 물어보면 컴퓨터는 무조건 **아니(False)**라고 대답합니다.

글자 하나만 입력받을 때는 그냥 answer = input()이라고 쓰시는 게 가장 안전합니다.

2.
이 if문에서 else: print(0)를 쓰면 안 되는 이유

이건 문제의 출력 형식 때문이에요.

채원님의 코드: 루프를 돌면서 단어를 확인하고, 조건에 안 맞으면 그때마다 0을 출력합니다.

결과 예시: apple 확인 -> 0 출력, banana 확인 -> 0 출력 ... 이렇게 0이 줄줄이 사탕으로 나오게 돼요.

문제의 요구사항: 조건에 맞는 단어들만 먼저 다 출력하고, 맨 마지막에 한 번만 총 개수를 출력하라고 했습니다.

그래서 else를 써서 0을 찍는 게 아니라, 조건에 맞을 때만 print(pick)를 하고 개수(count)를 쌓아둔 뒤, 루프가 완전히 끝난 밖에서 print(count)를 딱 한 번만 해줘야 합니다.
'''

############## 버블 소트


def bubble_sort(a,N):           # 정렬한 list, N 원소 수
    for i in range(N-1,0,-1):   # 범위의 끝 위치
        for j in range(i):      # 비교할 왼쪽 원소 인덱스 j
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]


# 1. 버블 정렬의 핵심: "제일 큰 놈부터 뒤로 보내기"
# 버블 정렬은 한 바퀴 돌 때마다 가장 큰 숫자가 맨 뒤 자리를 찾아가요.

# 첫 번째 바퀴 (i = 4): 0번부터 4번까지 비교하면서 제일 큰 놈(78)을 맨 끝 자리로 보냅니다. 이제 4번 자리는 주인(78)을 찾았으니 더 이상 건드릴 필요가 없죠?

# 두 번째 바퀴 (i = 3): 이제 맨 끝은 볼 필요 없으니까, 0번부터 3번까지만 비교해서 그중 제일 큰 놈(55)을 3번 자리로 보냅니다.

# 세 번째 바퀴 (i = 2): 이번엔 0번부터 2번까지만...

# 2. 왜 -1 (거꾸로) 방향인가요?
# 채원님이 말씀하신 "오른쪽에서 왼쪽으로 가는 것"이 맞아요! 하지만 숫자를 정렬하는 방향이 아니라, **"우리가 확인해야 할 담장의 위치"**를 옮기는 거예요.

# 처음엔 담장이 N-1 (맨 끝)에 있어요.

# 한 바퀴 돌면 끝이 정렬되니까 담장을 N-2로 한 칸 당겨요.

# 그다음엔 N-3으로...

# 이렇게 **"확인할 범위의 끝(i)"**을 뒤에서부터 앞으로 하나씩 줄여나가야 하기 때문에 (N-1, 0, -1)이라는 식을 쓰는 겁니다.

# 3. 이미지([7, 12, 42, 55, 78])로 이해하기
# 이미지에서 세로선(|)이 그어져 있는 걸 보세요.

# 오른쪽의 [42, 55, 78] 부분은 이미 자기 자리를 찾아서 고정된 상태예요.

# 왼쪽의 하늘색 부분 [7, 12]만 아직 "확인 중"인 범위인 거죠.

# i는 바로 저 세로선의 위치라고 생각하면 돼요! 바퀴를 돌 때마다 저 선이 왼쪽으로 한 칸씩 이동(-1)하면서 우리가 할 일을 줄여주는 고마운 녀석인 거죠.

# 💡 채원님을 위한 요약
# **i**는 "여기까지만 정렬하면 돼!"라고 알려주는 종점이에요.

# 뒤에서부터 정렬이 완료되니까 종점(i)도 뒤에서부터 앞으로 당겨와야 해서 거꾸로(-1) 가는 겁니다.

''''''

# 1. 파이썬의 마법: 마이너스(-) 인덱스
# 파이썬은 특이하게도 인덱스를 뒤에서부터 셀 수 있어요.

# 0부터 시작: 왼쪽에서 오른쪽 방향 (우리가 아는 방식)

# -1부터 시작: 오른쪽(끝)에서 왼쪽 방향 (파이썬의 지름길)

# 예를 들어 a = [10, 20, 30] 이라면:

# a[0]은 10이지만,

# **a[-1]**은 맨 마지막 놈인 **30**이 됩니다.

# a[-2]는 그 앞인 20이 되고요.

# 2. 왜 a[j] > a[j-1]을 쓰면 위험할까요?
# 아까 채원님이 물어보셨던 질문이랑 연결해 볼게요.

# for j in range(i): 루프가 시작되면 j는 0부터 시작하죠?

# 만약 코드를 if a[j] > a[j-1]: 이라고 썼다면?

# j가 0일 때 컴퓨터는 **a[0] > a[-1]**을 비교하게 됩니다.

# 즉, **"맨 앞의 숫자"**와 **"맨 뒤의 숫자"**를 갑자기 비교해버리는 꼴이 돼요!

# 버블 정렬은 바로 옆에 있는 친구랑 비교하면서 가야 하는데, 갑자기 맨 뒤에 있는 애랑 비교를 하면 정렬이 엉망진창이 되겠죠? 그래서 안전하게 **a[j](현재)와 a[j+1](오른쪽)**을 비교하는 방식을 쓰는 겁니다.

''''''

# 작아지는 순서로 셀 때: range(큰수, 작은수, -1)

# 커지는 순서로 셀 때: range(작은수, 큰수, 1)

# range의 규칙: "시작점에서 끝점까지 '방향'이 맞아야 해!"range(시작, 끝, 증감)은 일종의 기차와 같아요.range(9, 0, -1): 9번 역에서 출발해서 0번 역 방향으로 뒤로 한 칸씩(-1) 갑니다. 
# (9, 8, 7... 1까지) ==========> 출발지와 방향이 일치해서 정상 작동!
# range(0, 9, -1): 0번 역에서 출발해서 9번 역 방향으로 가야 하는데, 명령은 **"뒤로 한 칸씩 가!"**입니다. 
# 0에서 뒤로 가면 -1, -2... 이렇게 되죠? 그럼 9번 역에는 영원히 도착할 수 없어요. 
# =====> 파이썬은 "어? 이거 못 가네?" 하고 아무 숫자도 내뱉지 않습니다.
# 
# 2. 왜 굳이 N-1부터 시작해야 하나요?
# 버블 정렬의 목적을 다시 떠올려 보세요. 우리는 **"비교할 범위의 끝(담장)"**을 뒤에서부터 앞으로 하나씩 당겨오고 싶어 해요.
# N=10일 때, 처음 담장은 인덱스 9(N-1)에 있어야 하고, 그다음은 8, 7, 6... 순으로 줄어들어야 합니다.
# 이렇게 숫자가 작아지는 순서로 i를 만들려면, 
# 반드시 range(큰 숫자, 작은 숫자, -1) 꼴로 써야만 파이썬이 숫자를 만들어 줍니다.

''''''

# def bubble_sort(a,N):           # 정렬한 list, N 원소 수
#     for i in range(N-1,0,-1):   # 범위의 끝 위치
#         for j in range(i):      # 비교할 왼쪽 원소 인덱스 j
#             if a[j] > a[j+1]:
#                 a[j], a[j+1] = a[j+1], a[j]

# # 원래 코드 (>): 왼쪽이 크면 오른쪽으로 보내라! -> 작은 순서대로(오름차순(작은수->큰수))

# if a[j] < a[j+1]: (오름차순 ↔ 내림차순)  이건 정말 좋은 시도예요!

# 정렬 바꾼 코드 (<): 왼쪽이 작으면 오른쪽으로 보내라! -> 큰 순서대로(내림차순(큰수->작은수)) 
# 정렬결과: 부등호만 바꾸면 정렬의 방향을 내 마음대로 바꿀 수 있습니다.

''''''

# **바깥쪽 for문(i)을 "행(층수)"**이라고 생각하고, **안쪽 for문(j)을 "열(호수)"**이라고 생각하는 게 파이썬의 표준 약속이에요.

# 1. 왜 바깥쪽 i가 행(층수)일까?
# 우리가 아파트 도면을 읽는 순서를 생각해보세요.

# 바깥쪽 for i in range(n): "자, 이제 0층부터 훑어보자." (행 결정)

# 안쪽 for j in range(m): "0층에 왔으니까 0호, 1호, 2호... 순서대로 방문하자." (열 결정)

# 다음 바퀴: "0층 다 봤니? 그럼 이제 1층으로 올라가서 다시 0호, 1호, 2호... 보자."

# 2. 그때그때 다른가요?
# 이론적으로는 채원님이 i와 j의 역할을 바꿔서 코드를 짤 수도 있어요. 하지만 싸피(SSAFY) 시험이나 알고리즘 문제에서는 99% 확률로 아래와 같이 약속합니다.

# i = 행(Row) = 가로줄 = y좌표

# j = 열(Column) = 세로줄 = x좌표

# 그래서 보통 2차원 배열을 만들 때도 array[행][열] 순서로 쓰게 되는 거예요.

'''
바깥 for: 행 (Row, 가로줄)

안쪽 for: 열 (Column, 세로줄)

공식: array[바깥][안쪽] == array[행][열]
'''