# 1. 선택 정렬 (Selection Sort)

### "가장 작은 것을 '선택' 해서 맨 앞으로 보낸다"

```
def selection_sort(a, N):
for i in range(N-1):    # 정렬 구간의 시작점 (0부터 N-2까지)
min_idx = i     # 일단 첫 원소, 현재 자리를 최솟값으로 가정
for j in range(i+1, N):     # 시작점 다음(i+1)부터 끝까지 뒤지기
if a[min_idx] > a[j]:
min_idx = j     # 더 작은 놈 발견하면 인덱스 갱신
a[i], a[min_idx] = a[min_idx], a[i]   # 구간 최솟값을 구간 맨 앞[0] 으로 빼주기
```

### 서술형 풀이 가이드

선택 정렬은 전체 원소 중 최솟값을 찾아 정해진 위치로 이동시키는 방식입니다.작동 원리: 외부 루프의 인덱스 $i$는 최솟값이 들어갈 **'확정석'**을 의미합니다. 내부 루프 $j$는 $i$의 다음 칸부터 마지막 칸까지 순회하며 실제 최솟값이 위치한 인덱스(min_idx)를 찾아냅니다. 루프가 끝나면 단 한 번의 교환(swap)을 통해 해당 자리에 최솟값을 배치합니다.

### 범위의 이유

: range(N-1)인 이유는 마지막 하나 남은 원소는 자동으로 가장 큰 값이 되어 자기 자리에 남기 때문입니다 range(i+1, N)인 이유는 이미 확정된 앞부분(0~i)을 제외하고, 기준점(i)의 바로 다음부터 비교해야 효율적이기 때문입니다.

# 2. 거품 정렬 (Bubble Sort)

### "큰 값을 뒤로 밀어낸다"

```
def bubble_sort(a, N):
for i in range(N-1, 0, -1):   # 정렬될 마지막 위치를 뒤에서부터 줄여나감
for j in range(i):   # 인덱스 0부터 i-1까지 인접 원소 비교
if a[j] > a[j+1]:    # 왼쪽이 더 크면 오른쪽으로 밀기
a[j], a[j+1] = a[j+1], a[j]

```

거품 정렬은 인접한 두 원소를 비교하며 큰 값을 뒤로 계속 교환해 나가는 방식입니다.

### 작동 원리

: 한 번의 내부 루프가 끝나면 가장 큰 원소가 마치 거품이 올라오듯 배열의 **_맨 뒤 (오른쪽)_** 로 이동합니다. 따라서 외부 루프 i 는 정렬이 완료될 '끝 경계선'을 뒤에서부터 앞으로 좁혀나가는 역할을 합니다.

### 범위의 이유

: range(N-1, 0, -1)인 이유는 한 바퀴 돌 때마다 가장 큰 값이 맨 뒤에 고정되므로, 다음 루프에서는 그 자리를 제외하기 위해 끝 범위를 하나씩 줄여야 하기 때문입니다.
내부 루프가 range(i)인 이유는 a[j]와 a[j+1]을 비교할 때, j+1이 현재의 경계선인 i 에 딱 도달하게 하여 이미 정렬된 뒷부분을 건드리지 않기 위해서입니다.

## 선택 정렬 (Selection Sort) 모범답안

### [문제] 선택 정렬의 알고리즘 작동 원리와 코드에서 range(N-1) 및 range(i+1, N)을 사용하는 이유를 서술하시오.

### [답안]

선택 정렬은 전체 원소 중 최솟값을 찾아 정해진 위치로 이동시키는 정렬 방식입니다.

작동 원리: 주어진 구간의 첫 번째 인덱스를 최솟값의 위치(min_idx)로 가정합니다. 이후 나머지 구간을 순회하며 실제 최솟값을 가진 인덱스를 찾아 갱신하고, 내부 루프가 종료되면 기준 위치(i) 와 최솟값 위치(min_idx)의 원소를 교환(Swap)합니다.

외부 루프 range(N-1)의 이유 : 총 N개의 원소 중 N-1개의 위치가 확정되면, 마지막 남은 하나의 원소는 자동으로 가장 큰 값이 되어 마지막 자리에 남기 때문입니다.

내부 루프 range(i+1, N)의 이유: 기준 위치($i$)의 이전 인덱스들은 이미 정렬이 완료된 상태입니다. 따라서 기준 위치의 바로 다음 인덱스(i+1)부터 마지막 인덱스(N-1)까지만 비교하여 새로운 최솟값을 찾는 것이 효율적입니다.

## 거품 정렬 (Bubble Sort) 모범답안

### [문제] 거품 정렬의 알고리즘 작동 원리와 코드에서 range(N-1, 0, -1) 및 range(i)를 사용하는 이유를 서술하시오.

### [답안]

거품 정렬은 인접한 두 원소를 비교하여 큰 값을 뒤로 계속 교환해 나가는 정렬 방식입니다.

작동 원리: 인덱스 j와 j+1의 원소를 비교하여 왼쪽(j)이 더 크면 자리를 바꿉니다. 이 과정을 반복하면 한 번의 외부 루프가 끝날 때마다 해당 구간에서 가장 큰 원소가 배열의 맨 뒤로 이동합니다.

외부 루프 range(N-1, 0, -1)의 이유: 한 번의 순회가 끝날 때마다 가장 큰 숫자가 뒤에서부터 하나씩 확정됩니다. 따라서 정렬해야 할 범위의 끝 인덱스(i)를 뒤에서부터 앞으로 하나씩 줄여나가기 위해 역순 범위를 사용합니다.

내부 루프 range(i)의 이유: 인접한 두 원소($j, j+1$)를 비교할 때, 비교 대상 중 오른쪽 인덱스인 $j+1$이 현재 정렬되지 않은 구간의 끝인 $i$를 넘지 않도록 하기 위해서입니다.

### [문제] 2차원 배열에서 델타(Delta)를 이용한 탐색 시, if 0 <= ni < N and 0 <= nj < N 조건을 반드시 작성해야 하는 이유를 서술하시오.

### [답안]

**이유** : 배열의 가장자리(벽)에 위치한 원소를 탐색할 때, 계산된 이웃 좌표(ni, nj)가 배열의 인덱스 범위를 벗어날 수 있기 때문입니다.

**발생하는 문제** : 이 조건이 없다면 인덱스 범위를 초과하여 IndexError가 발생하거나, 파이썬의 경우 음수 인덱스로 인식되어 배열의 반대편 값을 읽어오는 논리적 오류가 생길 수 있습니다.

**효과** : 이 조건문을 통해 탐색하려는 좌표가 유효한 범위($0$부터 $N-1$ 사이) 내에 있을 때만 계산을 수행하여 프로그램의 안정성을 보장합니다.

### [문제] 선택 정렬과 거품 정렬의 시간 복잡도는 모두 $O(N^2)$으로 동일하지만, 실제 실행 시 '교환(Swap) 횟수' 측면에서 어떤 차이가 있는지 서술하시오.

### [답안]

**선택 정렬** : 내부 루프를 통해 최솟값의 위치를 먼저 찾은 뒤, 외부 루프의 마지막 단계에서 단 한 번만 교환을 수행합니다. 따라서 전체 교환 횟수는 O(N)으로 비교적 적습니다.

**거품 정렬** : 인접한 두 원소를 비교할 때마다 조건이 맞으면 즉시 교환을 수행합니다. 최악의 경우 교환 횟수가 $O(N^2)$에 달할 수 있습니다.

**결론** : 쓰기 연산(교환) 비용이 높은 환경에서는 같은 시간 복잡도라도 교환 횟수가 적은 선택 정렬이 거품 정렬보다 효율적일 수 있습니다.

# 🚀 거품 정렬 & 선택 정렬 재정리

## 1. 정렬 알고리즘 비교 (선택 정렬 vs 거품 정렬)

| 비교 항목     | **선택 정렬 (Selection Sort)**             | **거품 정렬 (Bubble Sort)**                |
| :------------ | :----------------------------------------- | :----------------------------------------- |
| **핵심 컨셉** | **최하위 후보**를 찾아 확정석에 앉히기     | **무거운 놈(큰 값)**을 끝으로 밀어내기     |
| **정렬 방향** | **왼쪽(인덱스 0)**부터 최솟값이 채워짐     | **오른쪽(인덱스 N-1)**부터 최댓값이 채워짐 |
| **비교 대상** | 기준점($i$)과 나머지 모든 원소($j$) 비교   | 인접한 두 원소($j$와 $j+1$)를 서로 비교    |
| **교환 횟수** | 외부 루프당 **최대 1회** (매우 효율적)     | 조건 만족 시 **수시로 발생** (잦은 교환)   |
| **스왑 위치** | 내부 루프($j$)가 **완전히 종료된 후** 수행 | `if` 조건문 만족 시 **즉시** 수행          |
| **핵심 변수** | `min_idx` (최솟값의 위치 기록용)           | `j, j+1` (인접 원소 비교용)                |
| **장단점**    | 데이터 이동 횟수가 적어 효율적임           | 구현이 단순하지만 교환이 잦아 느림         |

---

## 2. 상세 알고리즘 분석 및 구현 원리

### 🔍 선택 정렬 (Selection Sort)

> **"가장 작은 놈을 하나 골라서(선택) 맨 앞으로 보낸다"**

- **작동 원리**:
  - 정렬 구간의 첫 번째 인덱스를 일단 최솟값(`min_idx`)으로 **가정**합니다.
  - 그 다음 인덱스(`i+1`)부터 끝까지 순회하며 더 작은 값을 찾으면 `min_idx`를 **갱신**합니다.
  - 루프가 끝나면 기준 위치(`i`)와 진짜 최솟값 위치(`min_idx`)를 **단 한 번 교환**합니다.
- **코드 핵심 포인트**:
  - `range(N-1)`: 마지막 원소는 앞이 다 정해지면 자동으로 확정되므로 제외합니다.
  - `range(i+1, N)`: 기준점 자기 자신을 제외한 나머지 뒷부분만 수색합니다.

### 🫧 거품 정렬 (Bubble Sort)

> **"인접한 두 녀석을 비교해 큰 놈을 뒤로 밀어낸다(거품)"**

- **작동 원리**:
  - 인접한 두 원소(`j`, `j+1`)를 비교하여 왼쪽이 더 크면 **즉시 자리를 바꿉니다**.
  - 이 과정을 반복하면 한 바퀴 돌 때마다 가장 큰 숫자가 **오른쪽 끝**에 고정됩니다.
- **코드 핵심 포인트**:
  - `range(N-1, 0, -1)`: 큰 숫자가 뒤에서부터 쌓이므로, 조사 범위를 **뒤에서부터 한 칸씩 줄여나가는** 역순 범위를 사용합니다.
  - `range(i)`: 비교 대상 `j+1`이 확정된 경계선 `i`를 넘지 않도록 제한합니다.

---

## 3. 서술형 대비 핵심 이론 정리

### ✅ 2차원 배열 탐색 (델타 탐색)

- **벽 체크 필수**: 상하좌우 탐색 시 인덱스가 범위를 벗어나지 않도록 `if 0 <= ni < N and 0 <= nj < N` 조건을 반드시 작성해야 합니다.
- **절대값 계산**: 두 값의 차이를 구할 때는 `abs()` 함수를 쓰거나, 결과가 음수일 경우 `-`를 붙여 **양수로 변환**하여 합산합니다.

### ✅ 부분 수열 판별 (Greedy Search)

- **상대적 순서 유지**: 수열 A를 처음부터 끝까지 순회하며, 찾고자 하는 B의 원소를 발견했을 때만 인덱스를 증가시켜 **순차적**으로 확인합니다.
- **최종 판정**: 탐색 종료 후 내가 찾는 값이 수열 B의 길이와 같다면 모든 원소를 순서대로 찾은 것이므로 **YES**를 출력합니다.

### ✅ 파이썬 Swap (튜플 언패킹)

- `a[i], a[j] = a[j], a[i]` 구문을 사용하면 임시 변수(`temp`) 없이도 두 값을 직관적으로 교환할 수 있습니다.
